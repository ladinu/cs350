I wrote the following Python program to generate graphs from a given adjacency
matrix (it uses dot to generate graphs). 

#!/usr/bin/env python
import pydot as dot

def genGraph(matrix):
   graph = dot.Dot(graph_type='digraph')
   nodes = []
   for row_idx, row in enumerate(matrix):
      node = dot.Node("%i" % row_idx)
      graph.add_node(node)
      nodes.append(node)

   for row_idx, row in enumerate(matrix):
      for column_idx, element in enumerate(row):
         if element:
            graph.add_edge(dot.Edge(nodes[row_idx], nodes[column_idx]))

   graph.write_png("out.png")

I noticed the following patterns when generating graphs for the given network
topologies (star, ring, all connected)

   star
      - All nodes are connected to a single node and none of the nodes has a
        loop on itself.

      - The matrix would have to have all ones in its first row and first
        column expect for the very first element. For example, It would look
        like this for a 3 by 3 matrix

              [0, 1, 1]
              [1, 0, 0]
              [1, 0, 0]
               
        and like this for a n by n matrix:

              [0, 1, 1, ..., 1]
              [1, 0, 0, ..., 0]
              [1, 0, 0, ..., 0]
              [., 0, 0, ..., 0]
              [., 0, 0, ..., 0]
              [., 0, 0, ..., 0]
              [1, 0, 0, ..., 0]

      - Essentally, algorithm would have to check if the first row and column
        contain all 1s (execpt for the first element) and the rest are 0s.

      - This is the bruteforce algorithm that check if a n by n adjacency
        matrix represent a star network:

             if A[1, 1] = 1 then return false
             for i=2 to n do
                if A[1, i] \= 1 then return false
                if A[i, 1] \= 1 then return false
                for j=2 to n do
                  if A[i, j] \= 0 then return false 
             return true

   ring
      - In this type of network, the first node is connected to the second node
        and second node is connected to the third node and so on until last
        node is connected to the first node.

      - The adjacency matrix representation of this graph look like this for a
        3 by 3 matrix,

              [0, 1, 0]
              [0, 0, 1]
              [1, 0, 0]

        like this for a 4 by 4 matrix, 

              [0, 1, 0, 0]
              [0, 0, 1, 0]
              [0, 0, 0, 1]
              [1, 0, 0, 0]

        this pattern continues on for a n by n matrix

      - The following algorithm that check for a ring network. It check if all
        elements are 0 execpt for first element of the last row and each i+1
        element in i'th row.

            for i=1 to n do
               for j=1 to n do
                  if j == ((i+1) % n) then 
                     if A[i, j] \= 1 then return false
                  else
                     if A[i, j] \= 0 then return false
            return true

   all connected
      - As name implies, all the nodes are connected to each other. Each node
        will have n incomming edges. Beacuse none of the nodes are connected to
        itself, the diagonal of the adjacency matrix will all be 0s.

      - Beacuse all nodes are connected (execpt node to itself), the adjacency
        matrix will be filled with 1s execpt for the diagnoals. Matrix look
        like this for a 4 by 4 matrix
                     
             [0, 1, 1, 1]
             [1, 0, 1, 1]
             [1, 1, 0, 1]
             [1, 1, 1, 0]
              

      - The algorithm for checking if all alements of the adjacency matrix are
        1s execpt for the diagnoals is the following

            for i=1 to n do
               for j=1 to n do
                  if j == i then
                     if A[i, j] \= 0 then return false
                  else
                     if A[i, j] \= 1 then reutrn false
            return true

By combining all the algorithms given above, the following algorithm check if a
given n by n adjacency matrix represnt a star, ring or all connetcted network
toplogy

   // Input: A matrix A[1...n, 1...n] of booleans (1 or 0)
   // Output: Type of the network toplogy STAR, RING, ALL_CONNECTED, UNKNOWN
   function TOPOLOGY_TYPE( A[1...n, 1..n] )

      subroutine IS_STAR:
         if A[1, 1] = 1 then return false
         for i=2 to n do
            if A[1, i] \= 1 then return false
            if A[i, 1] \= 1 then return false
            for j=2 to n do
               if A[i, j] \= 0 then return false 
         return true 

      subroutine IS_RING:
         for i=1 to n do
            for j=1 to n do
               if j == ((i+1) % n) then 
                  if A[i, j] \= 1 then return false
               else
                  if A[i, j] \= 0 then return false
         return true


      subroutine IS_ALL_CONNECTED:
         for i=1 to n do
            for j=1 to n do
               if j == i then
                  if A[i, j] \= 0 then return false
               else
                  if A[i, j] \= 1 then reutrn false
            return true

      if IS_STAR then
         return STAR
      else if IS_RING then
         return RING
      else if IS_ALL_CONNECTED then
         return ALL_CONNECTED
      else
         return UNKNOWN
